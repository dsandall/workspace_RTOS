/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "spi.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "SPIRIT_Config.h" // API code for the expansion board
#include "spsgrf.h" //init code for the wireless module
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define MY_ADDRESS 176
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/*
 * spirit1_init
 */
void spirit1_init(){

/*	Reset the Xciever - Section 3.1 of the Digikey Post.
 *  Listing 1: Reset the SPIRIT1 by entering and exiting the SHUTDOWN state and then wait for it to enter the READY state
*/
	// restart the radio
	SpiritEnterShutdown();
	SpiritExitShutdown();
	SpiritManagementWaExtraCurrent(); // To be called at the SHUTDOWN exit. It avoids extra current consumption at SLEEP and STANDBY.

	// wait for the radio to enter the ready state
	do
	{
	  for (volatile uint8_t i = 0; i != 0xFF; i++); // delay for state transition
	  SpiritRefreshStatus(); // reads the MC_STATUS register
	} while (g_xStatus.MC_STATE != MC_STATE_READY);


/*	Radio Configuration - Section 3.2 of the Digikey Post.
 *  Listing 2: Configure the radio RF parameters and set the desired power level
*/
	SRadioInit xRadioInit;

	// Initialize radio RF parameters
	xRadioInit.nXtalOffsetPpm = XTAL_OFFSET_PPM;
	xRadioInit.lFrequencyBase = BASE_FREQUENCY;
	xRadioInit.nChannelSpace = CHANNEL_SPACE;
	xRadioInit.cChannelNumber = CHANNEL_NUMBER;
	xRadioInit.xModulationSelect = MODULATION_SELECT;
	xRadioInit.lDatarate = DATARATE;
	xRadioInit.lFreqDev = FREQ_DEVIATION;
	xRadioInit.lBandwidth = BANDWIDTH;
	SpiritRadioSetXtalFrequency(XTAL_FREQUENCY); // Must be called before SpiritRadioInit()
	SpiritRadioInit(&xRadioInit);

	// Set the transmitter power level
	SpiritRadioSetPALeveldBm(POWER_INDEX, POWER_DBM);
	SpiritRadioSetPALevelMaxIndex(POWER_INDEX);



/*	Packet Configuration - Section 3.3 of the Digikey Post.
 *  Listing 3: Configure the SPIRIT1 to use the Basic packet format by calling the SpiritPktBasicInit() and SpiritPktBasicAddressInit() functions.*/

//	PktBasicInit xBasicInit;
//	PktBasicAddressesInit xBasicAddress;
//
//	// Configure packet handler to use the Basic packet format
//	xBasicInit.xPreambleLength = PREAMBLE_LENGTH;
//	xBasicInit.xSyncLength = SYNC_LENGTH;
//	xBasicInit.lSyncWords = SYNC_WORD;
//	xBasicInit.xFixVarLength = LENGTH_TYPE;
//	xBasicInit.cPktLengthWidth = LENGTH_WIDTH;
//	xBasicInit.xCrcMode = CRC_MODE;
//	xBasicInit.xControlLength = CONTROL_LENGTH;
//	xBasicInit.xAddressField = EN_ADDRESS;
//	xBasicInit.xFec = EN_FEC;
//	xBasicInit.xDataWhitening = EN_WHITENING;
//	SpiritPktBasicInit(&xBasicInit);
//
//	// Configure destination address criteria for automatic packet filtering
//	xBasicAddress.xFilterOnMyAddress = EN_FILT_MY_ADDRESS;
//	xBasicAddress.cMyAddress = MY_ADDRESS;
//	xBasicAddress.xFilterOnMulticastAddress = EN_FILT_MULTICAST_ADDRESS;
//	xBasicAddress.cMulticastAddress = MULTICAST_ADDRESS;
//	xBasicAddress.xFilterOnBroadcastAddress = EN_FILT_BROADCAST_ADDRESS;
//	xBasicAddress.cBroadcastAddress = BROADCAST_ADDRESS;
//	SpiritPktBasicAddressesInit(&xBasicAddress);

	//TODO: finish this
	PktStackInit xSTackInit;
	PktStackAddressInit xSTackAddress;
	PktStackLlpInit xSTackLlp;

	xSTackInit.xPreambleLength = PREAMBLE_LENGTH;
	xSTackInit.xSyncLength = SYNC_LENGTH;
	xSTackInit.lSyncWords = SYNC_WORD; //double check this one?
	xSTackInit.xFixVarLength = LENGTH_TYPE;
	xSTackInit.cPktLengthWidth =

	xSTackAddress

	xSTackLlp

	SpiritPktStackInit(&xSTackInit);
	SpiritPktStackAddressesInit(&xSTackAddress);
	SpiritPktStackLlpInit(&xSTackLlp);




	/*	GPIO / IRQ Config - Section 3.4 of the Digikey Post.
	 *  Listing 4: Configure GPIO3 to send an interrupt signal when a TX/RX operation is completed, RX data was filtered and discarded, and/or the RX operation timed out.
	*/
	SGpioInit xGpioInit;

	// Configure GPIO3 as interrupt request pin (active low)
	xGpioInit.xSpiritGpioPin = SPIRIT_GPIO_3;
	xGpioInit.xSpiritGpioMode = SPIRIT_GPIO_MODE_DIGITAL_OUTPUT_LP;
	xGpioInit.xSpiritGpioIO = SPIRIT_GPIO_DIG_OUT_IRQ;
	SpiritGpioInit(&xGpioInit);

	// Generate an interrupt request for the following IRQs
	SpiritIrqDeInit(NULL);
	SpiritIrq(TX_DATA_SENT, S_ENABLE);
	SpiritIrq(RX_DATA_READY, S_ENABLE);
	SpiritIrq(RX_DATA_DISC, S_ENABLE);
	SpiritIrq(RX_TIMEOUT, S_ENABLE);
	SpiritIrqClearStatus();




	/*	Receiver Quality Indicators Configuration - Section 3.5 of the Digikey Post.
	 *  Listing 5: Set the RSSI/SQI thresholds and enable the SQI check to abort packet demodulation if the received synchronization field is corrupted.
	*/
	// Enable the synchronization quality indicator check (perfect match required)
	// NOTE: 9.10.4: "It is recommended to always enable the SQI check."
	SpiritQiSetSqiThreshold(SQI_TH_0);
	SpiritQiSqiCheck(S_ENABLE);

	// Set the RSSI Threshold for Carrier Sense (9.10.2)
	// NOTE: CS_MODE = 0 at reset
	SpiritQiSetRssiThresholddBm(RSSI_THRESHOLD);




	/*	Timer Configuration - Section 3.6 of the Digikey Post.
	 *  Listing 6: Conditionally set an RX timout of 2 seconds or infinity as well as configure the timer stop condition
	*/
	// Configure the RX timeout
	#ifdef RECEIVE_TIMEOUT
	SpiritTimerSetRxTimeoutMs(2000.0);
	#else
	SET_INFINITE_RX_TIMEOUT();
	#endif /* RECIEVE_TIMEOUT */
	SpiritTimerSetRxTimeoutStopCondition(SQI_ABOVE_THRESHOLD);



}


/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 40;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
